#!/usr/bin/env python3
import json
import os
from datetime import datetime
from collections import defaultdict

class CloudIAMAuditor:
    def __init__(self):
        self.output_dir = f"iam_audit_{int(datetime.now().timestamp())}"
        self.findings = defaultdict(list)
        self.risk_score = 0
        
    def audit_aws_iam(self, profile=None):
        print(f"\033[93m[*] Auditing AWS IAM permissions...\033[0m")
        
        try:
            import boto3
            
            session = boto3.Session(profile_name=profile) if profile else boto3.Session()
            
            iam = session.client('iam')
            
            print(f"\n\033[97m[1/6] Analyzing IAM users...\033[0m")
            self._audit_aws_users(iam)
            
            print(f"\n\033[97m[2/6] Analyzing IAM roles...\033[0m")
            self._audit_aws_roles(iam)
            
            print(f"\n\033[97m[3/6] Analyzing IAM policies...\033[0m")
            self._audit_aws_policies(iam)
            
            print(f"\n\033[97m[4/6] Analyzing IAM groups...\033[0m")
            self._audit_aws_groups(iam)
            
            print(f"\n\033[97m[5/6] Checking access keys...\033[0m")
            self._audit_aws_access_keys(iam)
            
            print(f"\n\033[97m[6/6] Checking MFA...\033[0m")
            self._audit_aws_mfa(iam)
            
            return True
        
        except ImportError:
            print(f"\033[91m[!] boto3 not installed. Run: pip install boto3\033[0m")
            return False
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return False
    
    def _audit_aws_users(self, iam):
        try:
            users = iam.list_users()['Users']
            
            print(f"\033[97m  Found {len(users)} IAM users\033[0m")
            
            for user in users:
                user_name = user['UserName']
                
                user_policies = iam.list_attached_user_policies(UserName=user_name)
                
                for policy in user_policies['AttachedPolicies']:
                    if 'Admin' in policy['PolicyName'] or 'FullAccess' in policy['PolicyName']:
                        print(f"\033[91m[!] User {user_name} has admin policy: {policy['PolicyName']}\033[0m")
                        
                        self.findings['admin_users'].append({
                            'user': user_name,
                            'policy': policy['PolicyName']
                        })
                        
                        self.risk_score += 5
        
        except Exception as e:
            print(f"\033[91m[!] Error auditing users: {e}\033[0m")
    
    def _audit_aws_roles(self, iam):
        try:
            roles = iam.list_roles()['Roles']
            
            print(f"\033[97m  Found {len(roles)} IAM roles\033[0m")
            
            for role in roles:
                role_name = role['RoleName']
                
                trust_policy = role['AssumeRolePolicyDocument']
                
                if isinstance(trust_policy, str):
                    trust_policy = json.loads(trust_policy)
                
                for statement in trust_policy.get('Statement', []):
                    principal = statement.get('Principal', {})
                    
                    if principal == '*' or principal.get('AWS') == '*':
                        print(f"\033[91m[!] Role {role_name} trusts wildcard principal!\033[0m")
                        
                        self.findings['wildcard_trust'].append({
                            'role': role_name,
                            'principal': principal
                        })
                        
                        self.risk_score += 10
                    
                    if 'Service' in principal and 'sts:AssumeRole' in statement.get('Action', []):
                        services = principal['Service'] if isinstance(principal['Service'], list) else [principal['Service']]
                        
                        for service in services:
                            if 'ec2' in service or 'lambda' in service:
                                role_policies = iam.list_attached_role_policies(RoleName=role_name)
                                
                                for policy in role_policies['AttachedPolicies']:
                                    if 'Admin' in policy['PolicyName']:
                                        print(f"\033[91m[!] Service role {role_name} has admin access\033[0m")
                                        
                                        self.findings['service_admin_roles'].append({
                                            'role': role_name,
                                            'service': service,
                                            'policy': policy['PolicyName']
                                        })
                                        
                                        self.risk_score += 7
        
        except Exception as e:
            print(f"\033[91m[!] Error auditing roles: {e}\033[0m")
    
    def _audit_aws_policies(self, iam):
        try:
            policies = iam.list_policies(Scope='Local')['Policies']
            
            print(f"\033[97m  Found {len(policies)} custom policies\033[0m")
            
            dangerous_actions = ['*:*', 'iam:*', 's3:*', 'ec2:*', 'lambda:*']
            
            for policy in policies:
                policy_arn = policy['Arn']
                policy_name = policy['PolicyName']
                
                policy_version = iam.get_policy_version(
                    PolicyArn=policy_arn,
                    VersionId=policy['DefaultVersionId']
                )
                
                policy_document = policy_version['PolicyVersion']['Document']
                
                if isinstance(policy_document, str):
                    policy_document = json.loads(policy_document)
                
                for statement in policy_document.get('Statement', []):
                    if statement.get('Effect') == 'Allow':
                        actions = statement.get('Action', [])
                        
                        if not isinstance(actions, list):
                            actions = [actions]
                        
                        for action in actions:
                            if action in dangerous_actions:
                                print(f"\033[91m[!] Policy {policy_name} allows dangerous action: {action}\033[0m")
                                
                                self.findings['dangerous_policies'].append({
                                    'policy': policy_name,
                                    'action': action,
                                    'resource': statement.get('Resource', 'Unknown')
                                })
                                
                                self.risk_score += 6
        
        except Exception as e:
            print(f"\033[91m[!] Error auditing policies: {e}\033[0m")
    
    def _audit_aws_groups(self, iam):
        try:
            groups = iam.list_groups()['Groups']
            
            print(f"\033[97m  Found {len(groups)} IAM groups\033[0m")
            
            for group in groups:
                group_name = group['GroupName']
                
                group_policies = iam.list_attached_group_policies(GroupName=group_name)
                
                for policy in group_policies['AttachedPolicies']:
                    if 'Admin' in policy['PolicyName']:
                        group_users = iam.get_group(GroupName=group_name)['Users']
                        
                        if len(group_users) > 5:
                            print(f"\033[91m[!] Admin group {group_name} has {len(group_users)} users\033[0m")
                            
                            self.findings['large_admin_groups'].append({
                                'group': group_name,
                                'user_count': len(group_users),
                                'policy': policy['PolicyName']
                            })
                            
                            self.risk_score += 4
        
        except Exception as e:
            print(f"\033[91m[!] Error auditing groups: {e}\033[0m")
    
    def _audit_aws_access_keys(self, iam):
        try:
            users = iam.list_users()['Users']
            
            for user in users:
                user_name = user['UserName']
                
                access_keys = iam.list_access_keys(UserName=user_name)['AccessKeyMetadata']
                
                if len(access_keys) > 1:
                    print(f"\033[93m[!] User {user_name} has {len(access_keys)} access keys\033[0m")
                    
                    self.findings['multiple_keys'].append({
                        'user': user_name,
                        'key_count': len(access_keys)
                    })
                
                for key in access_keys:
                    create_date = key['CreateDate']
                    age_days = (datetime.now(create_date.tzinfo) - create_date).days
                    
                    if age_days > 90:
                        print(f"\033[93m[!] Access key for {user_name} is {age_days} days old\033[0m")
                        
                        self.findings['old_keys'].append({
                            'user': user_name,
                            'key_id': key['AccessKeyId'],
                            'age_days': age_days
                        })
                        
                        self.risk_score += 2
        
        except Exception as e:
            print(f"\033[91m[!] Error auditing access keys: {e}\033[0m")
    
    def _audit_aws_mfa(self, iam):
        try:
            users = iam.list_users()['Users']
            
            users_without_mfa = []
            
            for user in users:
                user_name = user['UserName']
                
                mfa_devices = iam.list_mfa_devices(UserName=user_name)['MFADevices']
                
                if not mfa_devices:
                    users_without_mfa.append(user_name)
                    
                    user_policies = iam.list_attached_user_policies(UserName=user_name)
                    
                    for policy in user_policies['AttachedPolicies']:
                        if 'Admin' in policy['PolicyName']:
                            print(f"\033[91m[!] Admin user {user_name} has no MFA!\033[0m")
                            
                            self.findings['admin_no_mfa'].append(user_name)
                            
                            self.risk_score += 8
                            break
            
            if users_without_mfa:
                print(f"\033[93m[!] {len(users_without_mfa)} users without MFA\033[0m")
        
        except Exception as e:
            print(f"\033[91m[!] Error auditing MFA: {e}\033[0m")
    
    def audit_azure_rbac(self):
        print(f"\033[93m[*] Auditing Azure RBAC permissions...\033[0m")
        
        try:
            from azure.identity import DefaultAzureCredential
            from azure.mgmt.authorization import AuthorizationManagementClient
            from azure.mgmt.resource import SubscriptionClient
            
            credential = DefaultAzureCredential()
            
            subscription_client = SubscriptionClient(credential)
            
            subscriptions = list(subscription_client.subscriptions.list())
            
            print(f"\033[97m  Found {len(subscriptions)} subscriptions\033[0m")
            
            for subscription in subscriptions:
                print(f"\n\033[97m[*] Analyzing subscription: {subscription.display_name}\033[0m")
                
                auth_client = AuthorizationManagementClient(
                    credential,
                    subscription.subscription_id
                )
                
                role_assignments = list(auth_client.role_assignments.list())
                
                for assignment in role_assignments:
                    role_definition_id = assignment.role_definition_id
                    
                    role_definition = auth_client.role_definitions.get_by_id(role_definition_id)
                    
                    if 'Owner' in role_definition.role_name or 'Contributor' in role_definition.role_name:
                        print(f"\033[93m[!] Privileged role assigned: {role_definition.role_name}\033[0m")
                        
                        self.findings['azure_privileged_roles'].append({
                            'subscription': subscription.display_name,
                            'role': role_definition.role_name,
                            'principal_id': assignment.principal_id
                        })
                        
                        self.risk_score += 5
            
            return True
        
        except ImportError:
            print(f"\033[91m[!] Azure SDK not installed. Run: pip install azure-identity azure-mgmt-authorization azure-mgmt-resource\033[0m")
            return False
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return False
    
    def check_privilege_escalation_paths(self):
        print(f"\033[93m[*] Checking privilege escalation paths...\033[0m")
        
        escalation_paths = []
        
        if self.findings.get('admin_no_mfa'):
            escalation_paths.append({
                'path': 'Compromise admin account without MFA',
                'severity': 'Critical',
                'users': self.findings['admin_no_mfa']
            })
        
        if self.findings.get('wildcard_trust'):
            escalation_paths.append({
                'path': 'Assume role with wildcard trust',
                'severity': 'Critical',
                'roles': [f['role'] for f in self.findings['wildcard_trust']]
            })
        
        if self.findings.get('service_admin_roles'):
            escalation_paths.append({
                'path': 'Compromise EC2/Lambda with admin role',
                'severity': 'High',
                'roles': [f['role'] for f in self.findings['service_admin_roles']]
            })
        
        if escalation_paths:
            print(f"\n\033[91m[!] Found {len(escalation_paths)} privilege escalation paths:\033[0m")
            
            for i, path in enumerate(escalation_paths, 1):
                print(f"\033[97m  {i}. {path['path']} ({path['severity']})\033[0m")
        
        self.findings['escalation_paths'] = escalation_paths
        
        return escalation_paths
    
    def generate_report(self):
        os.makedirs(self.output_dir, exist_ok=True)
        
        report_file = os.path.join(self.output_dir, 'iam_audit_report.json')
        
        risk_level = 'Critical' if self.risk_score >= 30 else 'High' if self.risk_score >= 20 else 'Medium' if self.risk_score >= 10 else 'Low'
        
        report = {
            'audit_date': datetime.now().isoformat(),
            'output_directory': self.output_dir,
            'risk_score': self.risk_score,
            'risk_level': risk_level,
            'findings_count': sum(len(v) if isinstance(v, list) else 1 for v in self.findings.values()),
            'findings': dict(self.findings),
            'recommendations': self._generate_recommendations()
        }
        
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"\n\033[92m[+] Report saved: {report_file}\033[0m")
        print(f"\033[97m  Risk Score: {self.risk_score}/100\033[0m")
        print(f"\033[97m  Risk Level: {risk_level}\033[0m")
        print(f"\033[97m  Total Findings: {report['findings_count']}\033[0m")
    
    def _generate_recommendations(self):
        recommendations = []
        
        if self.findings.get('admin_no_mfa'):
            recommendations.append('Enable MFA for all privileged accounts')
        
        if self.findings.get('wildcard_trust'):
            recommendations.append('Remove wildcard principals from role trust policies')
        
        if self.findings.get('service_admin_roles'):
            recommendations.append('Apply principle of least privilege to service roles')
        
        if self.findings.get('old_keys'):
            recommendations.append('Rotate access keys older than 90 days')
        
        if self.findings.get('dangerous_policies'):
            recommendations.append('Restrict overly permissive IAM policies')
        
        return recommendations

def run():
    print("\033[92m" + "="*70)
    print("     CLOUD IAM PERMISSION AUDITOR")
    print("="*70 + "\033[0m\n")
    
    auditor = CloudIAMAuditor()
    
    print("\033[97mCloud IAM Audit Options:\033[0m")
    print("\033[97m  [1] Audit AWS IAM\033[0m")
    print("\033[97m  [2] Audit Azure RBAC\033[0m")
    print("\033[97m  [3] Check privilege escalation paths\033[0m")
    
    choice = input(f"\n\033[95m[?] Select option: \033[0m").strip()
    
    if choice == '1':
        profile = input("\033[95m[?] AWS profile (press Enter for default): \033[0m").strip() or None
        
        auditor.audit_aws_iam(profile)
        auditor.check_privilege_escalation_paths()
        auditor.generate_report()
    
    elif choice == '2':
        auditor.audit_azure_rbac()
        auditor.generate_report()
    
    elif choice == '3':
        print(f"\033[93m[*] Load existing audit data first\033[0m")
    
    print(f"\n\033[92m[+] Done\033[0m")

if __name__ == "__main__":
    run()
