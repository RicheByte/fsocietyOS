#!/usr/bin/env python3
import os
import subprocess
import platform
import json
from datetime import datetime
from collections import defaultdict

class PrivEscChecker:
    def __init__(self):
        self.os_type = platform.system()
        self.output_dir = f"privesc_{int(datetime.now().timestamp())}"
        self.findings = defaultdict(list)
        
    def check_sudo_permissions(self):
        print(f"\033[93m[*] Checking sudo permissions...\033[0m")
        
        try:
            result = subprocess.run(['sudo', '-l'], capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0:
                output = result.stdout
                
                if 'NOPASSWD' in output:
                    print(f"\033[92m[+] NOPASSWD sudo found!\033[0m")
                    
                    for line in output.split('\n'):
                        if 'NOPASSWD' in line:
                            self.findings['sudo_nopasswd'].append(line.strip())
                            print(f"\033[97m  {line.strip()}\033[0m")
                
                if '(ALL)' in output or '(ALL : ALL)' in output:
                    print(f"\033[92m[+] Full sudo access detected\033[0m")
                    self.findings['sudo_all'].append(output)
                
                return output
            else:
                print(f"\033[91m[!] Cannot check sudo (permission denied)\033[0m")
                return None
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return None
    
    def check_suid_files(self):
        print(f"\033[93m[*] Searching SUID binaries...\033[0m")
        
        try:
            cmd = ['find', '/', '-perm', '-4000', '-type', 'f', '2>/dev/null']
            
            result = subprocess.run(' '.join(cmd), shell=True, capture_output=True, text=True, timeout=120)
            
            suid_files = [f.strip() for f in result.stdout.split('\n') if f.strip()]
            
            print(f"\033[92m[+] Found {len(suid_files)} SUID binaries\033[0m")
            
            dangerous_binaries = ['nmap', 'vim', 'find', 'bash', 'more', 'less', 'nano', 'cp', 'mv', 'awk', 'man', 'wget', 'curl', 'nc', 'netcat', 'python', 'perl', 'ruby', 'lua', 'php', 'socat', 'taskset']
            
            for suid_file in suid_files:
                basename = os.path.basename(suid_file)
                
                if any(dangerous in basename for dangerous in dangerous_binaries):
                    print(f"\033[91m[!] DANGEROUS: {suid_file}\033[0m")
                    self.findings['suid_dangerous'].append(suid_file)
                else:
                    self.findings['suid_all'].append(suid_file)
            
            return suid_files
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return []
    
    def check_writable_paths(self):
        print(f"\033[93m[*] Checking writable PATH directories...\033[0m")
        
        try:
            path = os.environ.get('PATH', '').split(':')
            
            writable = []
            
            for directory in path:
                if os.path.isdir(directory):
                    if os.access(directory, os.W_OK):
                        print(f"\033[92m[+] Writable: {directory}\033[0m")
                        writable.append(directory)
                        self.findings['writable_path'].append(directory)
            
            return writable
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return []
    
    def check_cron_jobs(self):
        print(f"\033[93m[*] Checking cron jobs...\033[0m")
        
        cron_locations = [
            '/etc/crontab',
            '/etc/cron.d/',
            '/var/spool/cron/crontabs/',
            '/var/spool/cron/'
        ]
        
        cron_jobs = []
        
        for location in cron_locations:
            try:
                if os.path.isfile(location):
                    with open(location, 'r') as f:
                        content = f.read()
                        
                        if content.strip():
                            print(f"\033[97m  Found: {location}\033[0m")
                            cron_jobs.append({'file': location, 'content': content})
                            self.findings['cron_files'].append(location)
                
                elif os.path.isdir(location):
                    for root, dirs, files in os.walk(location):
                        for file in files:
                            file_path = os.path.join(root, file)
                            
                            try:
                                with open(file_path, 'r') as f:
                                    content = f.read()
                                    
                                    if content.strip():
                                        print(f"\033[97m  Found: {file_path}\033[0m")
                                        cron_jobs.append({'file': file_path, 'content': content})
                                        self.findings['cron_files'].append(file_path)
                            except:
                                pass
            
            except Exception as e:
                pass
        
        result = subprocess.run(['crontab', '-l'], capture_output=True, text=True)
        
        if result.returncode == 0 and result.stdout.strip():
            print(f"\033[97m  User crontab found\033[0m")
            cron_jobs.append({'file': 'user_crontab', 'content': result.stdout})
            self.findings['cron_user'].append(result.stdout)
        
        return cron_jobs
    
    def check_kernel_exploits(self):
        print(f"\033[93m[*] Checking kernel version for known exploits...\033[0m")
        
        try:
            result = subprocess.run(['uname', '-r'], capture_output=True, text=True, timeout=5)
            
            kernel_version = result.stdout.strip()
            
            print(f"\033[97m  Kernel: {kernel_version}\033[0m")
            
            exploits = {
                '2.6.22': ['Vmsplice', 'CVE-2008-0600'],
                '2.6.37': ['Full-Nelson', 'CVE-2010-4258'],
                '3.13.0': ['OverlayFS', 'CVE-2015-1328'],
                '3.16.0': ['OverlayFS', 'CVE-2015-8660'],
                '4.4.0': ['AF_PACKET', 'CVE-2016-8655'],
                '4.8.0': ['DirtyCow', 'CVE-2016-5195'],
                '4.15.0': ['DCCP', 'CVE-2017-6074'],
                '5.4.0': ['Baron Samedit', 'CVE-2021-3156']
            }
            
            for version, exploit_info in exploits.items():
                if version in kernel_version:
                    print(f"\033[92m[+] Potential exploit: {exploit_info[0]} ({exploit_info[1]})\033[0m")
                    self.findings['kernel_exploits'].append({
                        'version': kernel_version,
                        'exploit': exploit_info[0],
                        'cve': exploit_info[1]
                    })
            
            return kernel_version
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return None
    
    def check_capabilities(self):
        print(f"\033[93m[*] Checking file capabilities...\033[0m")
        
        try:
            cmd = ['getcap', '-r', '/', '2>/dev/null']
            
            result = subprocess.run(' '.join(cmd), shell=True, capture_output=True, text=True, timeout=120)
            
            capabilities = [f.strip() for f in result.stdout.split('\n') if f.strip()]
            
            print(f"\033[92m[+] Found {len(capabilities)} files with capabilities\033[0m")
            
            for cap in capabilities:
                print(f"\033[97m  {cap}\033[0m")
                self.findings['capabilities'].append(cap)
            
            return capabilities
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return []
    
    def check_world_writable(self):
        print(f"\033[93m[*] Searching world-writable files...\033[0m")
        
        try:
            cmd = ['find', '/', '-perm', '-2', '-type', 'f', '2>/dev/null']
            
            result = subprocess.run(' '.join(cmd), shell=True, capture_output=True, text=True, timeout=120)
            
            writable_files = [f.strip() for f in result.stdout.split('\n') if f.strip()][:50]
            
            print(f"\033[92m[+] Found {len(writable_files)} world-writable files (showing first 50)\033[0m")
            
            for file in writable_files[:20]:
                print(f"\033[97m  {file}\033[0m")
            
            self.findings['world_writable'] = writable_files
            
            return writable_files
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return []
    
    def check_nfs_shares(self):
        print(f"\033[93m[*] Checking NFS shares...\033[0m")
        
        nfs_files = ['/etc/exports', '/etc/fstab']
        
        nfs_shares = []
        
        for nfs_file in nfs_files:
            try:
                if os.path.exists(nfs_file):
                    with open(nfs_file, 'r') as f:
                        content = f.read()
                        
                        if 'nfs' in content.lower() or 'no_root_squash' in content:
                            print(f"\033[92m[+] NFS configuration found: {nfs_file}\033[0m")
                            
                            if 'no_root_squash' in content:
                                print(f"\033[91m[!] no_root_squash detected! (exploitable)\033[0m")
                            
                            nfs_shares.append({'file': nfs_file, 'content': content})
                            self.findings['nfs_shares'].append(nfs_file)
            
            except Exception:
                pass
        
        return nfs_shares
    
    def check_docker_socket(self):
        print(f"\033[93m[*] Checking Docker socket access...\033[0m")
        
        docker_socket = '/var/run/docker.sock'
        
        if os.path.exists(docker_socket):
            print(f"\033[92m[+] Docker socket found\033[0m")
            
            if os.access(docker_socket, os.R_OK | os.W_OK):
                print(f"\033[91m[!] Docker socket is accessible! (privilege escalation possible)\033[0m")
                self.findings['docker_socket'] = 'accessible'
                return True
            else:
                print(f"\033[97m  Docker socket not accessible\033[0m")
        
        return False
    
    def check_windows_privesc(self):
        print(f"\033[93m[*] Checking Windows privilege escalation vectors...\033[0m")
        
        if self.os_type != 'Windows':
            print(f"\033[91m[!] Not a Windows system\033[0m")
            return None
        
        checks = []
        
        print(f"\n\033[97m[*] Checking unquoted service paths...\033[0m")
        
        cmd = 'wmic service get name,pathname,displayname,startmode | findstr /i "auto" | findstr /i /v "c:\\windows\\\\" | findstr /i /v """'
        
        try:
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
            
            if result.stdout.strip():
                print(f"\033[92m[+] Unquoted service paths found\033[0m")
                checks.append({'check': 'unquoted_paths', 'result': result.stdout})
                self.findings['win_unquoted_paths'] = result.stdout.split('\n')
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
        
        print(f"\n\033[97m[*] Checking AlwaysInstallElevated...\033[0m")
        
        reg_keys = [
            r'HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer',
            r'HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer'
        ]
        
        for key in reg_keys:
            cmd = f'reg query "{key}" /v AlwaysInstallElevated'
            
            try:
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=10)
                
                if '0x1' in result.stdout:
                    print(f"\033[92m[+] AlwaysInstallElevated is enabled!\033[0m")
                    checks.append({'check': 'always_install_elevated', 'key': key})
                    self.findings['win_always_install'] = True
            
            except Exception:
                pass
        
        print(f"\n\033[97m[*] Checking scheduled tasks...\033[0m")
        
        cmd = 'schtasks /query /fo LIST /v'
        
        try:
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
            
            if result.stdout.strip():
                checks.append({'check': 'scheduled_tasks', 'result': result.stdout[:1000]})
                self.findings['win_scheduled_tasks'] = result.stdout.split('\n')[:50]
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
        
        return checks
    
    def automated_check(self):
        print(f"\033[93m[*] Running automated privilege escalation checks...\033[0m")
        
        if self.os_type == 'Linux':
            print(f"\n\033[97m[1/10] Sudo permissions\033[0m")
            self.check_sudo_permissions()
            
            print(f"\n\033[97m[2/10] SUID binaries\033[0m")
            self.check_suid_files()
            
            print(f"\n\033[97m[3/10] Writable PATH directories\033[0m")
            self.check_writable_paths()
            
            print(f"\n\033[97m[4/10] Cron jobs\033[0m")
            self.check_cron_jobs()
            
            print(f"\n\033[97m[5/10] Kernel exploits\033[0m")
            self.check_kernel_exploits()
            
            print(f"\n\033[97m[6/10] File capabilities\033[0m")
            self.check_capabilities()
            
            print(f"\n\033[97m[7/10] World-writable files\033[0m")
            self.check_world_writable()
            
            print(f"\n\033[97m[8/10] NFS shares\033[0m")
            self.check_nfs_shares()
            
            print(f"\n\033[97m[9/10] Docker socket\033[0m")
            self.check_docker_socket()
            
            print(f"\n\033[97m[10/10] Generating report\033[0m")
        
        elif self.os_type == 'Windows':
            self.check_windows_privesc()
        
        self.generate_report()
    
    def generate_report(self):
        os.makedirs(self.output_dir, exist_ok=True)
        
        report_file = os.path.join(self.output_dir, 'privesc_report.json')
        
        risk_score = 0
        
        if self.findings.get('sudo_nopasswd'):
            risk_score += 10
        if self.findings.get('suid_dangerous'):
            risk_score += 8
        if self.findings.get('writable_path'):
            risk_score += 6
        if self.findings.get('kernel_exploits'):
            risk_score += 9
        if self.findings.get('docker_socket') == 'accessible':
            risk_score += 10
        
        report = {
            'scan_date': datetime.now().isoformat(),
            'os_type': self.os_type,
            'output_directory': self.output_dir,
            'risk_score': risk_score,
            'risk_level': 'Critical' if risk_score >= 15 else 'High' if risk_score >= 10 else 'Medium' if risk_score >= 5 else 'Low',
            'findings': dict(self.findings)
        }
        
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"\n\033[92m[+] Report saved: {report_file}\033[0m")
        print(f"\033[97m  Risk Score: {risk_score}/50\033[0m")
        print(f"\033[97m  Risk Level: {report['risk_level']}\033[0m")

def run():
    print("\033[92m" + "="*70)
    print("     PRIVILEGE ESCALATION CHECKER")
    print("="*70 + "\033[0m\n")
    
    checker = PrivEscChecker()
    
    print(f"\033[97m  OS: {checker.os_type}\033[0m\n")
    
    print("\033[97mPrivilege Escalation Checks:\033[0m")
    print("\033[97m  [1] Check sudo permissions\033[0m")
    print("\033[97m  [2] Search SUID binaries\033[0m")
    print("\033[97m  [3] Check writable PATH\033[0m")
    print("\033[97m  [4] Check cron jobs\033[0m")
    print("\033[97m  [5] Check kernel exploits\033[0m")
    print("\033[97m  [6] Check file capabilities\033[0m")
    print("\033[97m  [7] Check Docker socket\033[0m")
    print("\033[97m  [8] Windows privilege escalation\033[0m")
    print("\033[97m  [9] Automated full scan\033[0m")
    
    choice = input(f"\n\033[95m[?] Select option: \033[0m").strip()
    
    if choice == '1':
        checker.check_sudo_permissions()
    
    elif choice == '2':
        checker.check_suid_files()
    
    elif choice == '3':
        checker.check_writable_paths()
    
    elif choice == '4':
        checker.check_cron_jobs()
    
    elif choice == '5':
        checker.check_kernel_exploits()
    
    elif choice == '6':
        checker.check_capabilities()
    
    elif choice == '7':
        checker.check_docker_socket()
    
    elif choice == '8':
        checker.check_windows_privesc()
    
    elif choice == '9':
        checker.automated_check()
    
    if choice != '9':
        checker.generate_report()
    
    print(f"\n\033[92m[+] Done\033[0m")

if __name__ == "__main__":
    run()
