#!/usr/bin/env python3
import requests
import os
import json
import re
from datetime import datetime
from collections import defaultdict

class ExploitDBDownloader:
    def __init__(self):
        self.base_url = 'https://www.exploit-db.com'
        self.api_url = 'https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv'
        self.output_dir = f"exploitdb_{int(datetime.now().timestamp())}"
        self.results = defaultdict(list)
        
    def search_exploits(self, keyword, platform=None, exploit_type=None):
        print(f"\033[93m[*] Searching Exploit-DB for: {keyword}\033[0m")
        
        search_url = f"{self.base_url}/search"
        
        params = {
            'q': keyword
        }
        
        if platform:
            params['platform'] = platform
        
        if exploit_type:
            params['type'] = exploit_type
        
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
            }
            
            response = requests.get(search_url, params=params, headers=headers, timeout=30)
            
            if response.status_code == 200:
                exploits = self._parse_search_results(response.text)
                
                print(f"\033[92m[+] Found {len(exploits)} exploits\033[0m")
                
                for i, exploit in enumerate(exploits[:20], 1):
                    print(f"\033[97m  {i}. [{exploit['id']}] {exploit['title']}\033[0m")
                    print(f"\033[90m     Platform: {exploit['platform']} | Type: {exploit['type']}\033[0m")
                
                return exploits
            else:
                print(f"\033[91m[!] Search failed: {response.status_code}\033[0m")
                return []
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return []
    
    def _parse_search_results(self, html_content):
        exploits = []
        
        id_pattern = r'exploits/(\d+)'
        title_pattern = r'<td class="col-left">(.*?)</td>'
        platform_pattern = r'<td>(.*?)</td>'
        
        ids = re.findall(id_pattern, html_content)
        titles = re.findall(title_pattern, html_content)
        
        for i in range(min(len(ids), len(titles))):
            exploits.append({
                'id': ids[i],
                'title': titles[i].strip(),
                'platform': 'multiple',
                'type': 'exploit'
            })
        
        return exploits
    
    def download_exploit(self, exploit_id):
        print(f"\033[93m[*] Downloading exploit ID: {exploit_id}\033[0m")
        
        os.makedirs(self.output_dir, exist_ok=True)
        
        download_url = f"{self.base_url}/download/{exploit_id}"
        
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
            }
            
            response = requests.get(download_url, headers=headers, timeout=30)
            
            if response.status_code == 200:
                file_ext = self._detect_file_extension(response.text)
                
                output_file = os.path.join(self.output_dir, f"{exploit_id}.{file_ext}")
                
                with open(output_file, 'w', encoding='utf-8') as f:
                    f.write(response.text)
                
                print(f"\033[92m[+] Downloaded: {output_file}\033[0m")
                
                self.results['downloaded'].append({
                    'id': exploit_id,
                    'file': output_file,
                    'size': len(response.text)
                })
                
                return output_file
            else:
                print(f"\033[91m[!] Download failed: {response.status_code}\033[0m")
                return None
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return None
    
    def _detect_file_extension(self, content):
        if '#!/usr/bin/python' in content or 'import ' in content:
            return 'py'
        elif '#!/bin/bash' in content or '#!/bin/sh' in content:
            return 'sh'
        elif '#include' in content:
            return 'c'
        elif '<?php' in content:
            return 'php'
        elif '<html' in content.lower():
            return 'html'
        else:
            return 'txt'
    
    def search_by_service(self, service_name, version=None):
        print(f"\033[93m[*] Searching exploits for service: {service_name}\033[0m")
        
        if version:
            keyword = f"{service_name} {version}"
        else:
            keyword = service_name
        
        return self.search_exploits(keyword)
    
    def search_by_cve(self, cve_id):
        print(f"\033[93m[*] Searching exploits for CVE: {cve_id}\033[0m")
        
        return self.search_exploits(cve_id)
    
    def download_multiple(self, exploit_ids):
        print(f"\033[93m[*] Downloading {len(exploit_ids)} exploits...\033[0m")
        
        downloaded = []
        
        for exploit_id in exploit_ids:
            output_file = self.download_exploit(exploit_id)
            
            if output_file:
                downloaded.append(output_file)
        
        print(f"\n\033[92m[+] Downloaded {len(downloaded)}/{len(exploit_ids)} exploits\033[0m")
        
        return downloaded
    
    def get_exploit_info(self, exploit_id):
        print(f"\033[93m[*] Getting exploit info: {exploit_id}\033[0m")
        
        info_url = f"{self.base_url}/exploits/{exploit_id}"
        
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
            }
            
            response = requests.get(info_url, headers=headers, timeout=30)
            
            if response.status_code == 200:
                info = self._parse_exploit_info(response.text)
                
                print(f"\033[92m[+] Title: {info.get('title', 'N/A')}\033[0m")
                print(f"\033[97m  Author: {info.get('author', 'N/A')}\033[0m")
                print(f"\033[97m  Date: {info.get('date', 'N/A')}\033[0m")
                print(f"\033[97m  Platform: {info.get('platform', 'N/A')}\033[0m")
                print(f"\033[97m  Type: {info.get('type', 'N/A')}\033[0m")
                
                return info
            else:
                print(f"\033[91m[!] Failed to get info: {response.status_code}\033[0m")
                return None
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return None
    
    def _parse_exploit_info(self, html_content):
        info = {}
        
        title_match = re.search(r'<h1[^>]*>(.*?)</h1>', html_content)
        if title_match:
            info['title'] = title_match.group(1).strip()
        
        author_match = re.search(r'Author:.*?<a[^>]*>(.*?)</a>', html_content)
        if author_match:
            info['author'] = author_match.group(1).strip()
        
        date_match = re.search(r'Published:.*?(\d{4}-\d{2}-\d{2})', html_content)
        if date_match:
            info['date'] = date_match.group(1)
        
        return info
    
    def search_recent(self, count=20, platform=None):
        print(f"\033[93m[*] Fetching {count} recent exploits...\033[0m")
        
        url = f"{self.base_url}/"
        
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
            }
            
            response = requests.get(url, headers=headers, timeout=30)
            
            if response.status_code == 200:
                exploits = self._parse_search_results(response.text)[:count]
                
                print(f"\033[92m[+] Found {len(exploits)} recent exploits\033[0m")
                
                for i, exploit in enumerate(exploits, 1):
                    print(f"\033[97m  {i}. [{exploit['id']}] {exploit['title']}\033[0m")
                
                return exploits
            else:
                return []
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return []
    
    def automated_service_search(self, services):
        print(f"\033[93m[*] Automated search for {len(services)} services...\033[0m")
        
        all_exploits = []
        
        for service in services:
            print(f"\n\033[97m[*] Searching: {service['name']} {service.get('version', '')}\033[0m")
            
            exploits = self.search_by_service(service['name'], service.get('version'))
            
            if exploits:
                all_exploits.extend(exploits[:5])
                
                print(f"\033[92m[+] Found {len(exploits)} exploits for {service['name']}\033[0m")
        
        print(f"\n\033[92m[+] Total exploits found: {len(all_exploits)}\033[0m")
        
        return all_exploits
    
    def analyze_exploit_code(self, file_path):
        print(f"\033[93m[*] Analyzing exploit code: {file_path}\033[0m")
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            analysis = {
                'file': file_path,
                'size': len(content),
                'lines': len(content.split('\n')),
                'language': self._detect_file_extension(content),
                'imports': [],
                'functions': [],
                'vulnerabilities': []
            }
            
            if 'import ' in content:
                imports = re.findall(r'import ([a-zA-Z0-9_\.]+)', content)
                analysis['imports'] = list(set(imports))
            
            if 'def ' in content:
                functions = re.findall(r'def ([a-zA-Z0-9_]+)\(', content)
                analysis['functions'] = list(set(functions))
            
            if 'CVE-' in content:
                cves = re.findall(r'CVE-\d{4}-\d+', content)
                analysis['vulnerabilities'] = list(set(cves))
            
            print(f"\033[92m[+] Analysis complete\033[0m")
            print(f"\033[97m  Language: {analysis['language']}\033[0m")
            print(f"\033[97m  Lines: {analysis['lines']}\033[0m")
            print(f"\033[97m  Imports: {len(analysis['imports'])}\033[0m")
            print(f"\033[97m  Functions: {len(analysis['functions'])}\033[0m")
            
            if analysis['vulnerabilities']:
                print(f"\033[97m  CVEs: {', '.join(analysis['vulnerabilities'])}\033[0m")
            
            return analysis
        
        except Exception as e:
            print(f"\033[91m[!] Error: {e}\033[0m")
            return None
    
    def generate_report(self):
        os.makedirs(self.output_dir, exist_ok=True)
        
        report_file = os.path.join(self.output_dir, 'exploitdb_report.json')
        
        report = {
            'session_date': datetime.now().isoformat(),
            'output_directory': self.output_dir,
            'total_downloaded': len(self.results['downloaded']),
            'downloads': self.results['downloaded']
        }
        
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"\n\033[92m[+] Report saved: {report_file}\033[0m")

def run():
    print("\033[92m" + "="*70)
    print("     EXPLOIT-DB SEARCH & DOWNLOAD TOOL")
    print("="*70 + "\033[0m\n")
    
    exploitdb = ExploitDBDownloader()
    
    print("\033[97mExploit-DB Options:\033[0m")
    print("\033[97m  [1] Search exploits by keyword\033[0m")
    print("\033[97m  [2] Search by service/version\033[0m")
    print("\033[97m  [3] Search by CVE\033[0m")
    print("\033[97m  [4] Download exploit\033[0m")
    print("\033[97m  [5] Get exploit info\033[0m")
    print("\033[97m  [6] Browse recent exploits\033[0m")
    print("\033[97m  [7] Automated service search\033[0m")
    
    choice = input(f"\n\033[95m[?] Select option: \033[0m").strip()
    
    if choice == '1':
        keyword = input("\033[95m[?] Search keyword: \033[0m").strip()
        
        exploitdb.search_exploits(keyword)
    
    elif choice == '2':
        service = input("\033[95m[?] Service name: \033[0m").strip()
        version = input("\033[95m[?] Version (optional): \033[0m").strip() or None
        
        exploitdb.search_by_service(service, version)
    
    elif choice == '3':
        cve = input("\033[95m[?] CVE ID (e.g., CVE-2021-1234): \033[0m").strip()
        
        exploitdb.search_by_cve(cve)
    
    elif choice == '4':
        exploit_id = input("\033[95m[?] Exploit ID: \033[0m").strip()
        
        file_path = exploitdb.download_exploit(exploit_id)
        
        if file_path:
            analyze = input("\033[95m[?] Analyze code? (y/n): \033[0m").strip().lower()
            
            if analyze == 'y':
                exploitdb.analyze_exploit_code(file_path)
        
        exploitdb.generate_report()
    
    elif choice == '5':
        exploit_id = input("\033[95m[?] Exploit ID: \033[0m").strip()
        
        exploitdb.get_exploit_info(exploit_id)
    
    elif choice == '6':
        count = input("\033[95m[?] Number of exploits (default 20): \033[0m").strip()
        count = int(count) if count.isdigit() else 20
        
        exploitdb.search_recent(count)
    
    elif choice == '7':
        services = []
        
        print("\n\033[97m[*] Enter services (empty to finish):\033[0m")
        
        while True:
            name = input("\033[95m[?] Service name: \033[0m").strip()
            
            if not name:
                break
            
            version = input("\033[95m[?] Version: \033[0m").strip()
            
            services.append({
                'name': name,
                'version': version if version else None
            })
        
        if services:
            exploitdb.automated_service_search(services)
    
    print(f"\n\033[92m[+] Done\033[0m")

if __name__ == "__main__":
    run()
